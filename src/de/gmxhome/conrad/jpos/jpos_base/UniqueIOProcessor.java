/*
 * Copyright 2019 Martin Conrad
 * <p>
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * http://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package de.gmxhome.conrad.jpos.jpos_base;

import jpos.JposConst;
import jpos.JposException;
import net.bplaced.conrad.log4jpos.Level;

import java.util.Arrays;

/**
 * Unique implementation for IO processing. Derived classes should add
 * support for serial (RS232), TCP and other IO operations
 */
public class UniqueIOProcessor {
    /**
     * Communication source, used for reading data. For RS232, Source, Target
     * and Port are the same. In case of network connections, they can be
     * different.
     */
    protected String Source;
    /**
     * Extended error code for JposExceptions generated by IO processors.
     */
    public static final int IOProcessorError = 1;
    /**
     * Gets source of previously read data.
     * @return Data source, null before data have been read
     */
    public String getSource() { return Source; }
    /**
     * Communication target, used for writing data. For RS232, Source, Target
     * and Port are the same. In case of network connections, they can be
     * different.
     */
    protected String Target;
    /**
     * Initial communication target, used to check whether source (read) or
     * target (write) shall be logged in read or write methods.
     */
    protected String InitialPort;
    /**
     * Retrieves currently set target for writing data.
     * @return Current target device, null if target has not been specified.
     */
    public String getTarget() { return Target; }
    /**
     * Sets communication target. Depending on the IO processor type, setting
     * communication target can be mandatory before calling method open.
     * @param target communication target
     * @return target
     * @throws JposException if target is not a valid communication target.
     */
    public String setTarget(String target) throws JposException { return Target = target; }
    /**
     * Communication port of the processor. Can be the name of a COM port
     * in case of RS232 or the the (own) port number in case of TCP or UDP.
     */
    protected String Port;

    /**
     * Logging prefix. String that will be used as prefix for all logging
     * messages. Default: Port + ": "
     */
    protected String LoggingPrefix;

    /**
     * Read timeout in milliseconds. Default: 0x10000000 (more than 8 years)
     */
    protected int Timeout = 0x10000000;

    /**
     * Sets read timeout
     * @param timeout Timeout in milliseconds
     * @return timeout
     */
    public int setTimeout(int timeout) { return Timeout = timeout; }
    /**
     * Logging type, one of LoggingTypeHexString, LoggingTypeEscapeString or LoggingTypeNoLogging. Default
     * LoggingTypeEscapeString.
     */
    protected int LoggingType = LoggingTypeEscapeString;
    /**
     * Sets the logging type for data logging.
     * @param type One of the LoggingType constants.
     * @return type
     */
    public int setLoggingType(int type) { return LoggingType = type; }
    /**
     * Logging type constant for hex-dump-style logging. If used, data will be
     * logged as pairs of two-digit hexadecimal digits, e.g. "Hello\n" as
     * 48 65 62 62 6F 0A.
     */
    public static final int LoggingTypeHexString = -1;

    /**
     * Logging type constant for excape-string style logging. If used, 7-bit
     * ASCII letters will be logged "as is", while all other values will be
     * logged as 3-letter octal triples with leading backslash. The backslash
     * will be duplicated, e.g. "Hello\n" as
     * Hello\012
     */
    public static final int LoggingTypeEscapeString = 1;

    /**
     * Logging type constant for no data logging. Data will be replaced by
     * ...
     */
    public static final int LoggingTypeNoLogging = 0;

    /**
     * Device used for logging
     */
    public JposDevice Dev;

    /**
     * Buffer with data to be logged in case of normal processing. In case
     * of exceptional processing, specific messages must be generated by
     * classes.
     */
    public byte[] LoggingData;

    /**
     * Synchronization object for write operations.
     */
    byte[] WriteSynchronizer = new byte[]{'W'};

    /**
     * Synchronization object for read operations.
     */
    byte[] ReadSynchronizer = new byte[]{'R'};

    /**
     * Generate log string from byte buffer
     * @param buffer byte array containing input or output data
     * @return String corresponding to previously specified logging type
     */
    public String toLogString(byte[] buffer) {
        String res = "";
        for (byte c : buffer) {
            switch (LoggingType) {
                case LoggingTypeHexString:
                    res += String.format(" %02X", c & 0xff);
                    break;
                case LoggingTypeEscapeString:
                    if (c < 0x20)
                        res += String.format("\\%03o", (int)c & 0xff);
                    else if (c == '\\')
                        res += "\\";
                    else
                        res += new String(new byte[]{c});
                    break;
                case LoggingTypeNoLogging:
                    return "...";
            }
        }
        return res;
    }

    /**
     * Stores JposDevice and port of derived IO processors. The device will
     * be used for logging while the port specifies the communication object.
     * @param dev   Device that uses the processor. Processor uses logging of device
     *              to produce logging entries
     * @param port  Communication object, e.g. COM3 or 127.0.0.1:23456
     * @throws JposException If port does not specify a valid communication object
     */
    public UniqueIOProcessor(JposDevice dev, String port) throws JposException {
        Dev = dev;
        Port = Source = Target = port;
        LoggingPrefix = port + ": ";
        InitialPort = port;
    }

    /**
     * Write a frame to the communication target. If called from a derived
     * class, the byte array must be passed through unchanged for correct
     * logging.
     * @param buffer    byte buffer containing the frame
     * @return  Number of bytes written to the target
     * @throws  JposException if something goes wrong
     */
    public int write(byte[] buffer) throws JposException {
        Dev.log(Level.TRACE, LoggingPrefix + "Write " + buffer.length + " byte" + location(false) +": " + toLogString(buffer));
        return buffer.length;
    }

    /**
     * Retrieves no. of readable units from communication source. If called from
     * a derived class, LoggingData must be filled with the count to be returned.
     * @return Unit count
     * @throws JposException if something goes wrong
     */
    public int available() throws JposException {
        try {
            int count = Integer.parseInt(new String(LoggingData));
            Dev.log(Level.ALL, LoggingPrefix + "Available bytes: " + count);
            return count;
        } catch (Exception e) {
            throw new JposException(JposConst.JPOS_E_ILLEGAL, IOProcessorError, "Available implementation error, no LoggingData available.");
        }
    }

    /**
     * Reads a frame of given maximum byte length from communication source. If called
     * from a derived class, LoggingData must be filled with the byte array to be
     * returned. If LoggingData is longer than the maximum length, the remaining bytes will be discarded.
     * @param count Maximum no. of bytes to be read
     * @return byte[] containing received bytes. In case of timeout, less than count
     * bytes will be returned, in extreme case, the array has length zero.
     * @throws JposException if something goes wrong
     */
    public byte[] read(int count) throws JposException {
        if (LoggingData == null)
            throw new JposException(JposConst.JPOS_E_ILLEGAL, IOProcessorError, "Read implementation error, no LoggingData available.");
        if (LoggingData.length > count) {
            byte[] data = Arrays.copyOf(LoggingData, count);
            byte[] remainder = Arrays.copyOfRange(LoggingData, count, LoggingData.length);
            Dev.log(Level.TRACE, LoggingPrefix + "Read " + data.length + " bytes" + location(true) + ": " + toLogString(data));
            Dev.log(Level.TRACE, LoggingPrefix + "Discard " + remainder.length + " bytes" + location(true) + ": " + toLogString(remainder));
            return data;
        } else {
            Dev.log(Level.TRACE, LoggingPrefix + "Read " + LoggingData.length + " bytes" + location(true) + ": " + toLogString(LoggingData));
            return LoggingData;
        }
    }

    /**
     * Generates string to be inserted into logging message whenever the source or target
     * port does not match the initial port.
     * @param from  True in case of reading date, false in case of writing data.
     * @return      enpty string if current port matches initial port, " from <i>getSource()</i>" or
     *              " to <i>getTarget()</i>" otherwise.
     */
    protected String location(boolean from) {
        String port = from ? getSource() : getTarget();
        return port.equals(InitialPort) ? "" : (from ? " from " : " to ") + port;
    }

    /**
     * Empties input and output buffer
     * @throws JposException Iif something goes wrong
     */
    public void flush() throws JposException {
        Dev.log(Level.TRACE, LoggingPrefix + "Flushed IO buffers.");
    }

    /**
     * Opens processor for communication to specific source / target. Communication
     * parameters must be set previously by specific setup method(s).
     * @param  noErrorLog  if set, no logging occurs in error case to avoid a flood
     *                     of error messages.
     * @throws JposException if an IO error occurs
     */
    public void open(boolean noErrorLog) throws JposException {
        Dev.log(Level.DEBUG, LoggingPrefix + "Opened successfully.");
    }

    /**
     * Finished any communication.
     * @throws JposException If an IO error occurs
     */
    public void close() throws JposException {
        Dev.log(Level.DEBUG, LoggingPrefix + "Closed successfully.");
    }

    /**
     * Generate a logging error message and throw the corresponding JposException.
     * @param what  Describes witch operation falied (e.g. "Read", "Available"...)
     * @param error The Jpos error constant
     * @param why   The error message.
     * @return      Function never returns, it throws an exception always.
     * @throws JposException  The exception. Its message will be set to why.
     */
    public int logerror(String what, int error, String why) throws JposException {
        Dev.log(Level.ERROR, LoggingPrefix + what + " error: " + why);
        throw new JposException(error, IOProcessorError, why);
    }

    /**
     * Generate a logging error message and throw an JposException.
     * @param what  Describes witch operation falied (e.g. "Read", "Available"...)
     * @param error The Jpos error constant
     * @param ex    JposException that lead to the error.
     * @return      Function never returns, it throws an exception always.
     * @throws JposException  The exception. Its message will be set to ex.getMessage().
     */
    public int logerror(String what, int error, Exception ex) throws JposException {
        Dev.log(Level.ERROR, LoggingPrefix + what + " error: " + ex.getMessage());
        if (ex instanceof JposException)
            throw (JposException) ex;
        else
            throw new JposException(error, IOProcessorError, ex.getMessage(), ex);
    }

    /**
     * Generate a logging error message and throw an JposException.
     * @param what  Describes witch operation falied (e.g. "Read", "Available"...)
     * @param ex    JposException that lead to the error.
     * @return      Function never returns, it throws an exception always.
     * @throws JposException  The exception. Its message will be set to ex.getMessage().
     */
    public int logerror(String what, JposException ex) throws JposException {
        Dev.log(Level.ERROR, LoggingPrefix + what + " error: " + ex.getMessage());
        throw (JposException) ex;
    }
}
